二叉树：
    1、前序、中序、后序遍历（递归和非递归方法）---实际6中遍历方式
        ---列出递归序：第一次出现打印即前序遍历；第二次出现打印即中序遍历；第三次出现打印即后序遍历。
        ---任意节点x：前序遍历中节点x前面部分与后续遍历x后面部分的交集，一定是x的祖先节点
        ---任意节点x，x的父类节点，x的子类节点，x的兄弟节点
    2、使用一个栈实现，迭代版本的后序遍历
    3、删除指定节点---链表
    4、层序遍历（利用队列）
    5、二叉树的序列化和反序列化（先序、后序、按层方式均可，，中序方式存在歧义，无序列化）
    6、多叉树---序列化---二叉树，该二叉树---反序列化---多叉树（深度优先遍历）
    7、统计出最大层的节点数量（容器法  --- 非容器法）
    8、给定二叉树中某个节点，返回其后继节点（二叉树结构中多了parent节点）
               --后继节点-中序遍历中节点的后续节点
    9、折纸--凹凸情况---二叉树中序遍历
    10、是否完全二叉树（1、有右无坐，否；2、当第一次遇到左右孩子不双全的时候，剩下遍历的节点不是叶子节点，否）
    11、给定一颗二叉树的头节点head,判断是否为平衡二叉树（每颗左右子树高度差绝对值<=1）---(满足三个条件：1、做子树是平衡树
            2、右子树是平衡树  3、左右子树高度差的绝对值< 2)
    12、如何判断一个二叉树是否是搜索二叉树（左子节点值  <  当前节点值 <  右子节点值）（方法一：中序遍历，判断是否有序）
        （1、左子树是搜索二叉树 2、右子树是搜索二叉树  3、当前节点是搜索二叉树（需获取左子树最大值，右子树最小值））
    13、给定一棵二叉树的头节点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离
        （1、x左树最大dis  2、x右树最大dis 3、x左树与x最大距离(高度) + x右树与x最大距离(高度) +1 ）
    14、判断一棵树是不是满二叉树（树高度是h，则节点数量一定是：2的h次方 - 1）--高度和节点数是否满足条件
    15、返回一个棵树符合搜索二叉树条件的最大子树（子树可能是其本身，也肯能不是）
    16、判断二叉树是否是完全二叉树---递归套路